# 基于PCF8574芯片的八段光条数码管模块测试程序 - MicroPython版本
## 目录
- [简介](#简介)
- [主要功能](#主要功能)
- [硬件要求](#硬件要求)
- [文件说明](#文件说明)
- [软件设计核心思想](#软件设计核心思想)
- [使用说明](#使用说明)
- [示例程序](#示例程序)
- [注意事项](#注意事项)
- [联系方式](#联系方式)
- [许可协议](#许可协议)
---
## 简介
PCF8574 是一款 I2C 接口的 GPIO 扩展芯片，可通过 2 根 I2C 引脚扩展 8 路 GPIO 口，广泛用于资源受限的嵌入式系统中扩展外设接口。本项目基于 PCF8574 芯片实现八段光条数码管控制

> **注意**：该程序仅适用于基于 PCF8574 芯片的八段光条led控制方案，不支持其他型号 GPIO 扩展芯片；
本项目提供基于 MicroPython 的驱动代码（`pcf8574.py`、`led_bar.py`）及测试主程序（`main.py`），方便开发者快速接入基于PCF8574芯片的八段光条数码管模块，实现稳定的led控制功能。
---
## 主要功能
- **I2C 接口扩展**：通过 PCF8574 芯片将 I2C 总线扩展为 GPIO 口，实现八段led控制
- **灵活的引脚映射**：支持自定义按键与 PCF8574 引脚的映射关系，适配不同硬件接线
- **跨平台兼容**：仅依赖 MicroPython 标准库，兼容 ESP32、ESP8266、树莓派 Pico 等开发板
- **资源释放优化**：程序终止时自动释放 I2C 总线资源，避免硬件占用冲突
---
## 硬件要求
### 推荐测试硬件
- MicroPython 兼容开发板（ESP32/ESP8266/树莓派 Pico）
- 八段光条数码管模块
- 杜邦线若干（至少 4 根：VCC、GND、SCL、SDA）
- （可选）面包板（便于临时接线测试）

### 模块引脚说明
| PCF8574 引脚 | 功能描述 | 电气特性 |
|--------------|----------|----------|
| VCC          | 电源正极 | 3.3V-5V（宽电压兼容） |
| GND          | 电源负极 | 接地，需与开发板共地 |
| SCL          | I2C 时钟线 | 单向时钟输入，需接开发板对应 I2C SCL 引脚 |
| SDA          | I2C 数据线 | 双向数据传输，需接开发板对应 I2C SDA 引脚 |
---
## 文件说明
### 1. pcf8574.py
核心类为 `PCF8574`，用于实现 PCF8574 芯片的 I2C 通信与 GPIO 控制，各方法作用如下：
- `__init__(self, i2c, address=0x20)`：初始化 PCF8574 实例，建立与芯片的 I2C 通信连接；参数 `i2c` 为应用层已初始化的 I2C 实例，`address` 为芯片的 I2C 地址（默认 0x20，可通过芯片 A0/A1/A2 引脚调整）。
- `read(self) -> int`：读取 8 路 GPIO 口的当前整体状态，返回 1 字节整数；整数的每一位对应 1 路引脚，1 表示高电平，0 表示低电平。
- `write(self, value)`：向 8 路 GPIO 口写入控制数据，设置输出状态；参数 `value` 为 1 字节整数，每一位对应 1 路引脚的输出电平（1 高电平，0 低电平）。
- `set_pin(self, pin, value)`：单独控制某一路 GPIO 口的输出状态；参数 `pin` 为引脚编号（0-7），`value` 为输出电平（True 高电平，False 低电平）。
- `get_pin(self, pin) -> bool`：单独读取某一路 GPIO 口的输入状态；参数 `pin` 为引脚编号（0-7），返回布尔值（True 高电平，False 低电平）。

### 2. led_bar.py
核心类为 `LEDBar`，基于通过 PCF8574 控制 8 段光条（8 个 LED），提供单灯控制、一次性写入和按级别点亮等常用方法，各方法作用如下：
- `__init__(pcf8574)`：构造函数，验证 pcf8574 必须实现 `check`、`pin`、`toggle` 等方法，初始化时会调用 `clear()` 清除所有 LED。
- `set_led(index, value)`：设置单个 LED（`index` 0~7），`value` 为 `True`（点亮）或 `False`（熄灭）；索引越界会抛出 `ValueError`。
- `set_all(value) `：一次写入 8 位状态， `value ` 为 0~255 的整数，会把值赋给  `pcf.port `；超出范围抛出  `ValueError `。
- `clear() `：熄灭所有 LED（等同于  `set_all(0x00)`）。

### 3. main.py
无自定义类，为测试主程序，核心逻辑通过函数调用实现：
- 初始化 I2C 总线：配置 I2C 引脚（默认 SCL=GPIO5、SDA=GPIO4）与通信频率，创建 I2C 实例。
- 实例化硬件类：创建 `PCF8574` 实例（指定 I2C 地址 0x20）和 `LEDBar` 实例（引脚映射）。
- 主循环逻辑：顺序演示操作（按序执行，操作间有延时）
  - 点亮单个 LED：点亮索引 2（第 3 个 LED），等待 1 秒。
  - 熄灭该单个 LED，等待 1 秒。
  - 一次性写入所有 LED：写入 0b00001111（点亮前 4 个），等待 1 秒。
  - 按等级显示：调用 display_level(6)（点亮前 6 个），等待 1 秒。
  - 跑马灯效果：循环 8 次，逐位移动点亮，间隔 0.2 秒。
  最后全部熄灭：调用 clear() 结束。
---
## 软件设计核心思想
### 分层设计
- 底层：`pcf8574.py` 封装 PCF8574 芯片的 I2C 通信与 GPIO 操作，屏蔽硬件寄存器细节，提供通用 GPIO 控制接口。
- 中层：`led_bar.py` 基于底层驱动，输出电平控制模块。
- 高层：`main.py` 作为应用示例，组合调用底层与中层模块，演示完整使用流程，降低开发者移植难度。

### 接口解耦
- 硬件初始化分离：I2C 实例由应用层创建并传入 `PCF8574` 类，驱动不绑定具体硬件引脚，适配 ESP32、树莓派 Pico 等不同开发板。
- 回调函数注入：按键状态的处理逻辑通过 `callback` 参数注入，开发者可灵活扩展功能（如控制 LED、发送串口指令等），无需修改驱动代码。

### 跨平台兼容
- 依赖最小化：仅使用 MicroPython 标准库（`machine`、`time`），不依赖硬件平台专属 API，确保在不同 MicroPython 开发板上均可运行。
- 配置参数化：I2C 引脚、设备地址、按键映射、消抖时间等均通过参数配置，修改 `main.py` 中的参数即可适配不同硬件接线，无需改动驱动文件。
---
## 使用说明
### 硬件接线（树莓派pico 示例）
| PCF8574 引脚 |  GPIO 引脚 | 五向按键模块连接 | 备注 |
|--------------|----------------|------------------|------|
| VCC          | 3.3V           | -                | 若模块支持 5V 可接 5V，避免过压损坏 |
| GND          | GND            | GND（按键公共地） | 必须与开发板共地，否则按键状态检测异常 |
| SCL          | GPIO17         | -                | 需与开发板 I2C SCL 引脚对应，不同开发板引脚不同 |
| SDA          | GPIO16         | -                | 需与开发板 I2C SDA 引脚对应，不同开发板引脚不同 |

> **注意：**
> - 树莓派 Pico 常用 I2C 引脚：I2C 0（SCL=GP1、SDA=GP0）、I2C 1（SCL=GP3、SDA=GP2），需根据实际使用的 I2C 总线调整接线。

### 软件依赖
- **固件版本**：MicroPython v1.23.0 及以上  
- **内置库**：
  - `machine`：提供 I2C 总线初始化、GPIO 控制功能
  - `time`：提供时间戳记录、延时功能，用于消抖与循环间隔控制
- **开发工具**：推荐 Thonny（操作简单，支持 MicroPython 直接运行与调试）、PyCharm（需安装 MicroPython 插件）

### 安装步骤
1. **烧录固件**：根据开发板型号（如 ESP32、树莓派 Pico）下载对应 MicroPython 固件，通过烧录工具（如 esptool、Raspberry Pi Imager）烧录到开发板。
2. **上传文件**：通过开发工具将 `pcf8574.py`、`led_bar.py`、`main.py` 三个文件上传到开发板根目录。
3. **修改配置**：打开 `main.py`，根据硬件接线修改 I2C 引脚（`SCL_PIN`、`SDA_PIN`）、PCF8574 地址（`PCF8574_ADDR`）、按键-引脚映射（`KEYS_MAP`）。
4. **运行测试**：在开发工具中运行 `main.py`，操作五向按键，通过串口监视器查看按键状态打印信息（按下/释放）。
---
## 示例程序
```python
# Python env   : MicroPython v1.23.0
# -*- coding: utf-8 -*-
# @Time    : 2025/09/08 10:00
# @Author  : 侯钧瀚
# @File    : main.py
# @Description : 基于PCF8574芯片的八段光条数码管模块

# ======================================== 导入相关模块 =========================================

from machine import I2C, Pin
#导入pcf8574模块
from pcf8574 import PCF8574
#导入基于PCF8574芯片的八段光条数码管模块
from led_bar import LEDBar
#时间相关模块
import time

# ======================================== 全局变量 ============================================

# ======================================== 功能函数 ============================================


# ======================================== 自定义类 ============================================

# ======================================== 初始化配置 ==========================================

# 上电延时3s
time.sleep(3)
# 打印调试消息
print("FreakStudio: Test PCF8574 Module")
i2c = I2C(id=0, sda=Pin(4), scl=Pin(5), freq=100000)
# 开始扫描I2C总线上的设备，返回从机地址的列表
devices_list = i2c.scan()
print('START I2C SCANNER')

# 若devices_list为空，则没有设备连接到I2C总线上
if len(devices_list) == 0:
    print("No i2c device !")
# 若非空，则打印从机设备地址
else:
    print('i2c devices found:', len(devices_list))
    # 遍历从机设备地址列表
    for device in devices_list:
        # 判断设备地址是否为PCF8575的地址
        if device >= 0x20 and device <= 0x27:
            print("I2C hexadecimal address: ", hex(device))
# 初始化 PCF8574，假设地址为 0x20
pcf = PCF8574(i2c, address=device)

# ========================================  主程序  ===========================================

# 创建 LEDBar 实例
ledbar = LEDBar(pcf)
# 1. 单个 LED 点亮（点亮第 3 个 LED）
ledbar.set_led(2, True)
time.sleep(1)

# 2. 单个 LED 熄灭（关闭第 3 个 LED）
ledbar.set_led(2, False)
time.sleep(1)

# 3. 设置所有 LED（例如点亮前 4 个）
ledbar.set_all(0b00001111)
time.sleep(1)

# 4. 显示 level（例如点亮前 6 个 LED）
ledbar.display_level(6)
time.sleep(1)

# 5. 跑马灯效果
for i in range(8):
    ledbar.set_all(1 << i)
    time.sleep(0.2)

# 6. 全部熄灭
ledbar.clear()

```
---
## 注意事项
### 1. 硬件连接问题
- **电源匹配**：PCF8574 模块若为 3.3V 版本，不可接 5V 电源；5V 版本可兼容 3.3V，但需确认模块是否带电压转换电路，避免芯片烧毁。
- **共地要求**：PCF8574 的 GND 必须与开发板 GND 直接连接，否则 I2C 通信会因电平参考不一致导致失败或数据异常。
- **上拉电阻**：PCF8574 引脚为开漏输出，作为按键输入时需上拉（模块内置或外接）；无上天拉时，按键按下/释放状态可能无法正确检测。

### 2. 软件配置问题
- **I2C 地址冲突**：若同一 I2C 总线连接多个设备，需确保各设备地址不同（PCF8574 地址可通过 A0/A1/A2 引脚调整，范围 0x20-0x27），避免通信冲突。
- **消抖时间调整**：若按键仍有误触发，可增大 `debounce_time`（如 100ms）；若按键响应迟钝，可适当减小（如 30ms），需根据按键机械特性调整。
- **循环间隔控制**：主循环中 `update()` 调用间隔建议不超过 `debounce_time` 的一半（如消抖 50ms 时，间隔 20ms），确保不遗漏按键状态变化。

### 3. 性能与稳定性
- **采样频率**：单次按键检测（`read_all()`+`update()`）耗时约 1-2ms，建议每秒采样不超过 100 次，避免占用过多 CPU 资源影响其他功能。
- **资源释放**：程序终止时需通过键盘中断（Ctrl+C）触发资源释放逻辑，避免直接断电导致 I2C 总线处于异常状态，影响下次启动。
- **环境干扰**：强电磁环境（如电机、继电器附近）可能干扰 I2C 通信，建议使用屏蔽线连接 SCL/SDA 引脚，或增加 100nF 滤波电容（靠近 PCF8574 VCC-GND 引脚）。
---

## 联系方式
如有任何问题或需要帮助，请通过以下方式联系开发者：  
📧 **邮箱**：1098875044@qq.com  
💻 **GitHub**：https://github.com/FreakStudioCN

---

## 许可协议
本项目中，除 `machine` 等 MicroPython 官方模块（MIT 许可证）外，所有由作者编写的驱动与扩展代码均采用 **知识共享署名-非商业性使用 4.0 国际版 (CC BY-NC 4.0)** 许可协议发布。  

您可以自由地：  
- **共享** — 在任何媒介以任何形式复制、发行本作品  
- **演绎** — 修改、转换或以本作品为基础进行创作  

惟须遵守下列条件：  
- **署名** — 您必须给出适当的署名，提供指向本许可协议的链接，同时标明是否（对原始作品）作了修改。您可以用任何合理的方式来署名，但是不得以任何方式暗示许可人为您或您的使用背书。  
- **非商业性使用** — 您不得将本作品用于商业目的。  
- **合理引用方式** — 可在代码注释、文档、演示视频或项目说明中明确来源。  
- **说明** — 代码含参考部分,出现非技术问题和署名作者无关。  
**版权归 FreakStudio 所有。**
